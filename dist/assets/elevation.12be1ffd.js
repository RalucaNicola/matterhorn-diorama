import{a8 as H,cs as N,ct as P,bL as S,bU as Y,cn as z,ck as B,ad as U,aC as D,aP as G}from"./index.25dca4c3.js";const I=H.getLogger("esri.geometry.support.meshUtils.elevation");async function O(e,a,t){let s;if(L(e)||e instanceof N){var r;return s=await(await J(e)).createElevationSampler(a,{demResolution:(r=t==null?void 0:t.demResolution)!=null?r:"finest-contiguous"}),F(s,a,{material:t==null?void 0:t.material})}return typeof(t==null?void 0:t.demResolution)=="string"?(I.error("create()","demResolution must be a number when used directly with a sampler"),null):F(e,a,{material:t==null?void 0:t.material,demResolution:t==null?void 0:t.demResolution})}function F(e,a,t){var s,r;const g=z(a.spatialReference),A=((s=t.demResolution)!=null?s:e.demResolution.min)/g,u=Math.round(a.width/A),c=Math.round(a.height/A),o=u+1,R=c+1,m=new Float64Array(o*R*3),w=new Float32Array(o*R*2);let p=0,b=0;const n=new Uint32Array(u*c*2*3);let l=0,i=0;const M=!e.spatialReference.equals(a.spatialReference);v.spatialReference=a.spatialReference;const{xmin:$,ymin:j,height:q,width:C}=a;for(let d=0;d<R;d++){const y=j+q*(d/c);for(let f=0;f<o;f++){const h=$+C*(f/u);if(m[p++]=h,m[p++]=y,M){v.x=h,v.y=y;const x=B(v,e.spatialReference);m[p++]=U(e.elevationAt(x.x,x.y),0)}else m[p++]=U(e.elevationAt(h,y),0);const k=f/u,E=d/c;w[b++]=k,w[b++]=E,d!==c&&f!==u&&(n[i++]=l+1,n[i++]=l+o+1,n[i++]=l+o,n[i++]=l,n[i++]=l+1,n[i++]=l+o),l++}}return new P({vertexAttributes:new S({position:m,uv:w}),components:[new Y({faces:n,shading:"smooth",material:(r=t==null?void 0:t.material)!=null?r:null})],spatialReference:a.spatialReference})}async function J(e){return L(e)?e.load():(await e.load(),await D(e.layers.map(a=>a.load())),e)}function L(e){return"type"in e&&(e.type==="elevation"||e.type==="base-elevation")}const v=new G;export{O as create};
