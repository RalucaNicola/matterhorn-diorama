var it=Object.defineProperty,st=Object.defineProperties;var rt=Object.getOwnPropertyDescriptors;var Se=Object.getOwnPropertySymbols;var at=Object.prototype.hasOwnProperty,nt=Object.prototype.propertyIsEnumerable;var Ie=(n,e,t)=>e in n?it(n,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[e]=t,Y=(n,e)=>{for(var t in e||(e={}))at.call(e,t)&&Ie(n,t,e[t]);if(Se)for(var t of Se(e))nt.call(e,t)&&Ie(n,t,e[t]);return n},re=(n,e)=>st(n,rt(e));import{gI as ot,gJ as lt,gK as D,gL as je,gM as pe,gN as Oe,r as H,cj as ut,gO as J,gP as Re,I as R,t as A,cR as ct,$ as X,gQ as ue,cv as ce,cY as he,g1 as ht,gR as dt,gS as Fe,gT as de,gU as fe,gV as ft,gW as mt,gX as pt,gY as yt,gZ as gt,g_ as xt,g$ as ve,h0 as be,h1 as _t,h2 as wt,h3 as St,b0 as qe,h4 as It,h5 as Rt,h6 as se,h7 as Te,h8 as W,h9 as Ft,ha as vt,cL as bt,hb as Tt,ak as Ze,hc as At,fk as Et,aA as Ae,b as Ee,cu as Z,ft as zt,fu as $t,hd as Qt,cn as ae,ay as ze,he as Vt,g3 as $e,hf as Gt,b4 as Mt}from"./index.165b2b59.js";import{WhereClause as Ct}from"./WhereClause.d10f799a.js";import{t as ke}from"./json.d1a0fa35.js";import{t as Pt}from"./QueryEngineCapabilities.c2e9875c.js";import{T as Nt,s as Dt,m as Qe,c as Ve,V as jt,g as Ot,h as qt,y as Zt,D as kt,z as Bt,f as Ut,d as Lt}from"./utils.d0f28677.js";const ne=[0,0];function Be(n,e){if(!e)return null;if("x"in e){const t={x:0,y:0};return[t.x,t.y]=n(e.x,e.y,ne),e.z!=null&&(t.z=e.z),e.m!=null&&(t.m=e.m),t}if("xmin"in e){const t={xmin:0,ymin:0,xmax:0,ymax:0};return[t.xmin,t.ymin]=n(e.xmin,e.ymin,ne),[t.xmax,t.ymax]=n(e.xmax,e.ymax,ne),e.hasZ&&(t.zmin=e.zmin,t.zmax=e.zmax,t.hasZ=!0),e.hasM&&(t.mmin=e.mmin,t.mmax=e.mmax,t.hasM=!0),t}return"rings"in e?{rings:Ge(e.rings,n),hasM:e.hasM,hasZ:e.hasZ}:"paths"in e?{paths:Ge(e.paths,n),hasM:e.hasM,hasZ:e.hasZ}:"points"in e?{points:Ue(e.points,n),hasM:e.hasM,hasZ:e.hasZ}:void 0}function Ge(n,e){const t=[];for(const i of n)t.push(Ue(i,e));return t}function Ue(n,e){const t=[];for(const i of n){const s=e(i[0],i[1],[0,0]);t.push(s),i.length>2&&s.push(i[2]),i.length>3&&s.push(i[3])}return t}async function U(n,e){if(!e)return;const t=Array.isArray(n)?n.map(i=>H(i.geometry)&&i.geometry.spatialReference):[n];await ut(t.map(i=>({source:i,dest:e})))}const Le=Be.bind(null,ot),He=Be.bind(null,lt);function M(n,e,t){if(!n||(t||(t=e,e=n.spatialReference),!J(e)||!J(t)||D(e,t)))return n;if(je(e,t)){const i=pe(t)?Le(n):He(n);return i.spatialReference=t,i}return Oe(ke,[n],e,t,null)[0]}class Ht{constructor(){this._jobs=[],this._timer=null,this._process=this._process.bind(this)}async push(e,t,i){if(!e||!e.length||!t||!i||D(t,i))return e;const s={geometries:e,inSpatialReference:t,outSpatialReference:i,resolve:null};return this._jobs.push(s),new Promise(r=>{s.resolve=r,this._timer===null&&(this._timer=setTimeout(this._process,10))})}_process(){this._timer=null;const e=this._jobs.shift();if(!e)return;const{geometries:t,inSpatialReference:i,outSpatialReference:s,resolve:r}=e;je(i,s)?pe(s)?r(t.map(Le)):r(t.map(He)):r(Oe(ke,t,i,s,null)),this._jobs.length>0&&(this._timer=setTimeout(this._process,10))}}const Jt=new Ht;function Yt(n,e,t){return Jt.push(n,e,t)}class Wt{constructor(e,t){this._cache=new Re(e),this._invalidCache=new Re(t)}get(e,t){const i=`${t.uid}:${e}`,s=this._cache.get(i);if(s)return s;if(this._invalidCache.get(i)!==void 0)return null;try{const r=Ct.create(e,t);return this._cache.put(i,r),r}catch{return this._invalidCache.put(i,null),null}}}const ye=new Wt(50,500),P="feature-store:unsupported-query",Je=" as ",Xt=new Set(["esriFieldTypeOID","esriFieldTypeSmallInteger","esriFieldTypeInteger","esriFieldTypeSingle","esriFieldTypeDouble","esriFieldTypeLong","esriFieldTypeDate"]);function Kt(n,e){if(!e)return!0;const t=ye.get(e,n);if(!t)throw new R(P,"invalid SQL expression",{where:e});if(!t.isStandardized)throw new R(P,"where clause is not standard",{where:e});return G(n,t.fieldNames,"where clause contains missing fields"),!0}function ei(n,e,t){if(!e)return!0;const i=ye.get(e,n);if(!i)throw new R(P,"invalid SQL expression",{having:e});if(!i.isAggregate)throw new R(P,"having does not contain a valid aggregate function",{having:e});const s=i.fieldNames;if(G(n,s,"having contains missing fields"),!i.getExpressions().every(r=>{const{aggregateType:a,field:o}=r,l=n.has(o)&&n.get(o).name;return t.some(u=>{const{onStatisticField:c,statisticType:h}=u;return(n.has(c)&&n.get(c).name)===l&&h.toLowerCase().trim()===a})}))throw new R(P,"expressions in having should also exist in outStatistics",{having:e});return!0}function B(n,e){return n?ye.get(n,e):null}function G(n,e,t,i=!0){const s=[];for(const r of e)if(r!=="*"&&!n.has(r))if(i){const a=Ye(r);try{const o=B(a,n);if(!o)throw new R(P,"invalid SQL expression",{where:a});if(!o.isStandardized)throw new R(P,"expression is not standard",{clause:o});G(n,o.fieldNames,"expression contains missing fields")}catch(o){const l=o&&o.details;if(l&&(l.clause||l.where))throw o;l&&l.missingFields?s.push(...l.missingFields):s.push(r)}}else s.push(r);if(s.length)throw new R(P,t,{missingFields:s})}function Ye(n){return n.split(Je)[0]}function ti(n){return n.split(Je)[1]}function ii(n,e){const t=e.get(n);return!!t&&!Xt.has(t.type)}class te{constructor(e,t,i){this._fieldDataCache=new Map,this._returnDistinctMap=new Map,this.returnDistinctValues=e.returnDistinctValues,this.fieldsIndex=i,this.featureAdapter=t;const s=e.outFields;if(s&&!s.includes("*")){this.outFields=s;let r=0;for(const a of s){const o=Ye(a),l=this.fieldsIndex.get(o),u=l?null:B(o,i),c=l?l.name:ti(a)||"FIELD_EXP_"+r++;this._fieldDataCache.set(a,{alias:c,clause:u})}}}countDistinctValues(e){return this.returnDistinctValues?(e.forEach(t=>this.getAttributes(t)),this._returnDistinctMap.size):e.length}getAttributes(e){const t=this._processAttributesForOutFields(e);return this._processAttributesForDistinctValues(t)}getFieldValue(e,t,i){const s=i?i.name:t;let r=null;return this._fieldDataCache.has(s)?r=this._fieldDataCache.get(s).clause:i||(r=B(t,this.fieldsIndex),this._fieldDataCache.set(s,{alias:s,clause:r})),i?this.featureAdapter.getAttribute(e,s):r.calculateValue(e,this.featureAdapter)}getNormalizedValue(e,t){const i=t.normalizationType,s=t.normalizationTotal;let r=this.getFieldValue(e,t.field,t.fieldInfo);if(i&&Number.isFinite(r)){const a=this.getFieldValue(e,t.normalizationField,t.normalizationFieldInfo);r=Nt(r,i,a,s)}return r}getExpressionValue(e,t,i){const s={attributes:this.featureAdapter.getAttributes(e)},r=i.createExecContext(s,t.viewInfo);return i.executeFunction(t.compiledFunc,r)}validateItem(e,t){return this._fieldDataCache.has(t)||this._fieldDataCache.set(t,{alias:t,clause:B(t,this.fieldsIndex)}),this._fieldDataCache.get(t).clause.testFeature(e,this.featureAdapter)}validateItems(e,t){return this._fieldDataCache.has(t)||this._fieldDataCache.set(t,{alias:t,clause:B(t,this.fieldsIndex)}),this._fieldDataCache.get(t).clause.testSet(e,this.featureAdapter)}_processAttributesForOutFields(e){const t=this.outFields;if(!t||!t.length)return this.featureAdapter.getAttributes(e);const i={};for(const s of t){const{alias:r,clause:a}=this._fieldDataCache.get(s);i[r]=a?a.calculateValue(e,this.featureAdapter):this.featureAdapter.getAttribute(e,r)}return i}_processAttributesForDistinctValues(e){if(A(e)||!this.returnDistinctValues)return e;const t=this.outFields,i=[];if(t)for(const a of t){const{alias:o}=this._fieldDataCache.get(a);i.push(e[o])}else for(const a in e)i.push(e[a]);const s=`${(t||["*"]).join(",")}=${i.join(",")}`;let r=this._returnDistinctMap.get(s)||0;return this._returnDistinctMap.set(s,++r),r>1?null:e}}function si(n,e){if(!n)return null;const t=e.featureAdapter,{startTimeField:i,endTimeField:s}=n;let r=Number.POSITIVE_INFINITY,a=Number.NEGATIVE_INFINITY;if(i&&s)e.forEach(o=>{const l=t.getAttribute(o,i),u=t.getAttribute(o,s);l==null||isNaN(l)||(r=Math.min(r,l)),u==null||isNaN(u)||(a=Math.max(a,u))});else{const o=i||s;e.forEach(l=>{const u=t.getAttribute(l,o);u==null||isNaN(u)||(r=Math.min(r,u),a=Math.max(a,u))})}return{start:r,end:a}}function ri(n,e,t){if(!e||!n)return null;const{startTimeField:i,endTimeField:s}=n;if(!i&&!s)return null;const{start:r,end:a}=e;return r===null&&a===null?null:r===void 0&&a===void 0?oi():i&&s?ai(t,i,s,r,a):ni(t,i||s,r,a)}function ai(n,e,t,i,s){return i!=null&&s!=null?r=>{const a=n.getAttribute(r,e),o=n.getAttribute(r,t);return(a==null||a<=s)&&(o==null||o>=i)}:i!=null?r=>{const a=n.getAttribute(r,t);return a==null||a>=i}:s!=null?r=>{const a=n.getAttribute(r,e);return a==null||a<=s}:void 0}function ni(n,e,t,i){return t!=null&&i!=null&&t===i?s=>n.getAttribute(s,e)===t:t!=null&&i!=null?s=>{const r=n.getAttribute(s,e);return r>=t&&r<=i}:t!=null?s=>n.getAttribute(s,e)>=t:i!=null?s=>n.getAttribute(s,e)<=i:void 0}function oi(){return()=>!1}const li=new ct({esriSRUnit_Meter:"meters",esriSRUnit_Kilometer:"kilometers",esriSRUnit_Foot:"feet",esriSRUnit_StatuteMile:"miles",esriSRUnit_NauticalMile:"nautical-miles",esriSRUnit_USNauticalMile:"us-nautical-miles"}),V=Object.freeze({}),Me=new X,ui=new X,me=new X,oe={esriGeometryPoint:fe,esriGeometryPolyline:pt,esriGeometryPolygon:yt,esriGeometryMultipoint:gt};function Ce(n,e,t,i=n.hasZ,s=n.hasM){if(A(e))return null;const r=n.hasZ&&i,a=n.hasM&&s;if(t){const o=de(me,e,n.hasZ,n.hasM,"esriGeometryPoint",t,i,s);return fe(o,r,a)}return fe(e,r,a)}function C(n,e,t,i,s,r,a=e,o=t){const l=e&&a,u=t&&o,c=H(i)?"coords"in i?i:i.geometry:null;if(A(c))return null;if(s){let h=ft(ui,c,e,t,n,s,a,o);return r&&(h=de(me,h,l,u,n,r)),oe[n](h,l,u)}if(r){const h=de(me,c,e,t,n,r,a,o);return oe[n](h,l,u)}return mt(Me,c,e,t,a,o),oe[n](Me,l,u)}async function k(n,e,t){const{outFields:i,orderByFields:s,groupByFieldsForStatistics:r,outStatistics:a}=n;if(i)for(let o=0;o<i.length;o++)i[o]=i[o].trim();if(s)for(let o=0;o<s.length;o++)s[o]=s[o].trim();if(r)for(let o=0;o<r.length;o++)r[o]=r[o].trim();if(a)for(let o=0;o<a.length;o++)a[o].onStatisticField&&(a[o].onStatisticField=a[o].onStatisticField.trim());return n.geometry&&!n.outSR&&(n.outSR=n.geometry.spatialReference),ci(n,e,t)}async function ci(n,e,t){if(!n)return null;let{where:i}=n;if(n.where=i=i&&i.trim(),(!i||/^1 *= *1$/.test(i)||e&&e===i)&&(n.where=null),!n.geometry)return n;let s=await hi(n);if(n.distance=0,n.units=null,n.spatialRel==="esriSpatialRelEnvelopeIntersects"){const{spatialReference:l}=n.geometry;s=ue(s),s.spatialReference=l}n.geometry=s,await U(s.spatialReference,t);const r=(await ce(he(s)))[0];if(A(r))throw V;const a=r.toJSON(),o=await M(a,a.spatialReference,t);if(!o)throw V;return o.spatialReference=t,n.geometry=o,n}async function hi(n){const{geometry:e,distance:t,units:i}=n;if(t==null||"vertexAttributes"in e)return e;const s=e.spatialReference,r=i?li.fromJSON(i):ht(s),a=s&&(dt(s)||pe(s))?e:await U(s,Fe).then(()=>M(e,Fe));return(await di())(a.spatialReference,a,t,r)}async function di(){return(await import("./geometryEngineJSON.5b19a683.js")).geodesicBuffer}function L(n){return n&&We in n?JSON.parse(JSON.stringify(n,fi)):n}const We="_geVersion",fi=(n,e)=>n!==We?e:void 0;class F{constructor(e,t,i){this.items=e,this.queryGeometry=t,this.definitionExpression=i.definitionExpression,this.geometryType=i.geometryType,this.hasM=i.hasM,this.hasZ=i.hasZ,this.objectIdField=i.objectIdField,this.spatialReference=i.spatialReference,this.fieldsIndex=i.fieldsIndex,this.timeInfo=i.timeInfo,this.featureAdapter=i.featureAdapter,this.aggregateAdapter=i.aggregateAdapter}get size(){return this.items.length}createQueryResponseForCount(e){const t=new te(e,this.featureAdapter,this.fieldsIndex);if(!e.outStatistics)return t.countDistinctValues(this.items);const{groupByFieldsForStatistics:i,having:s}=e;if(!(i!=null&&i.length))return 1;const r=new Map,a=new Map,o=new Set,l=e.outStatistics;for(const u of l){const{statisticType:c}=u,h=c!=="exceedslimit"?u.onStatisticField:void 0;if(!a.has(h)){const m=[];for(const d of i){const _=this._getAttributeValues(t,d,r);m.push(_)}a.set(h,this._calculateUniqueValues(m,t.returnDistinctValues))}const f=a.get(h);for(const m in f){const{data:d,items:_}=f[m],S=d.join(",");s&&!t.validateItems(_,s)||o.add(S)}}return o.size}async createQueryResponse(e){let t;return e.outStatistics?t=e.outStatistics.some(i=>i.statisticType==="exceedslimit")?this._createExceedsLimitQueryResponse(e):await this._createStatisticsQueryResponse(e):t=this._createFeatureQueryResponse(e),e.returnQueryGeometry&&(J(e.outSR)&&!D(this.queryGeometry.spatialReference,e.outSR)?t.queryGeometry=L(Y({spatialReference:e.outSR},M(this.queryGeometry,this.queryGeometry.spatialReference,e.outSR))):t.queryGeometry=L(Y({spatialReference:e.outSR},this.queryGeometry))),t}createSnappingResponse(e,t){const i=this.featureAdapter,s=pi(this.hasZ,this.hasM),{x:r,y:a}=e.point,o=typeof e.distance=="number"?e.distance:e.distance.x,l=typeof e.distance=="number"?e.distance:e.distance.y,u={candidates:[]},c=this.geometryType==="esriGeometryPolygon",h=this._getPointCreator(e.point,this.spatialReference,t);for(const f of this.items){const m=i.getGeometry(f);if(A(m))continue;const{coords:d,lengths:_}=m;if(e.types&K.EDGE){let S=0;for(let w=0;w<_.length;w++){const p=_[w];for(let x=0;x<p;x++,S+=s){const I=d[S],y=d[S+1];if(x!==p-1){const g=d[S+s],v=d[S+s+1],{x:E,y:N}=mi(r,a,I,y,g,v),b=(r-E)/o,z=(a-N)/l,j=b*b+z*z;j<=1&&u.candidates.push({type:"edge",objectId:i.getObjectId(f),distance:Math.sqrt(j),target:h(E,N),start:h(I,y),end:h(g,v)})}}}}if(e.types&K.VERTEX){const S=c?d.length-s:d.length;for(let w=0;w<S;w+=s){const p=d[w],x=d[w+1],I=(r-p)/o,y=(a-x)/l,g=I*I+y*y;g<=1&&u.candidates.push({type:"vertex",objectId:i.getObjectId(f),distance:Math.sqrt(g),target:h(p,x)})}}}return u.candidates.sort((f,m)=>f.distance-m.distance),u}_getPointCreator(e,t,i){const s=H(i)&&!D(t,i)?r=>M(r,t,i):r=>r;return e.z!=null&&e.m!=null?(r,a)=>s({x:r,y:a,z:e.z,m:e.m}):e.z!=null?(r,a)=>s({x:r,y:a,z:e.z}):e.m!=null?(r,a)=>s({x:r,y:a,m:e.m}):(r,a)=>s({x:r,y:a})}executeAttributesQuery(e){const t=B(e.where,this.fieldsIndex);if(!t)return Promise.resolve(this);if(t.isStandardized){let i=0;const s=[];for(const a of this.items)t.testFeature(a,this.featureAdapter)&&(s[i++]=a);const r=new F(s,this.queryGeometry,this);return r.definitionExpression=e.where,Promise.resolve(r)}return Promise.reject(new TypeError("Where clause is not standardized"))}executeAggregateIdsQuery(e){if(!e.aggregateIds||!e.aggregateIds.length||A(this.aggregateAdapter))return Promise.resolve(this);const t=new Set;for(const s of e.aggregateIds)this.aggregateAdapter.getFeatureObjectIds(s).forEach(r=>t.add(r));const i=this.featureAdapter.getObjectId;return Promise.resolve(new F(this.items.filter(s=>t.has(i(s))),this.queryGeometry,this))}executeObjectIdsQuery(e){if(!e.objectIds||!e.objectIds.length)return Promise.resolve(this);const t=new Set(e.objectIds),i=this.featureAdapter.getObjectId;return Promise.resolve(new F(this.items.filter(s=>t.has(i(s))),this.queryGeometry,this))}executeTimeQuery(e){const t=ri(this.timeInfo,e.timeExtent,this.featureAdapter);if(A(t))return Promise.resolve(this);const i=this.items.filter(t);return Promise.resolve(new F(i,this.queryGeometry,this))}filterLatest(){const{trackIdField:e,startTimeField:t,endTimeField:i}=this.timeInfo,s=i||t,r=new Map,a=this.featureAdapter.getAttribute;for(const l of this.items){const u=a(l,e),c=a(l,s),h=r.get(u);(!h||c>a(h,s))&&r.set(u,l)}const o=Array.from(r.values());return Promise.resolve(new F(o,this.queryGeometry,this))}async project(e){if(!e||D(this.spatialReference,e))return this;const t=this.featureAdapter,i=(await Yt(this.items.map(s=>C(this.geometryType,this.hasZ,this.hasM,t.getGeometry(s))),this.spatialReference,e)).map((s,r)=>t.cloneWithGeometry(this.items[r],xt(s,this.hasZ,this.hasM)));return new F(i,this.queryGeometry,{definitionExpression:this.definitionExpression,geometryType:this.geometryType,hasM:this.hasM,hasZ:this.hasZ,objectIdField:this.objectIdField,spatialReference:e,fieldsIndex:this.fieldsIndex,timeInfo:this.timeInfo,featureAdapter:this.featureAdapter})}async createSummaryStatisticsResponse(e,t){const{field:i,valueExpression:s,normalizationField:r,normalizationType:a,normalizationTotal:o,minValue:l,maxValue:u,scale:c}=t,h=this.fieldsIndex.isDateField(i),f=await this._getDataValues(e,{field:i,valueExpression:s,normalizationField:r,normalizationType:a,normalizationTotal:o,scale:c}),m=Dt({normalizationType:a,normalizationField:r,minValue:l,maxValue:u}),d=this.fieldsIndex.get(i),_={value:.5,fieldType:d==null?void 0:d.type},S=ve(d)?Qe({values:f,supportsNullCount:m,percentileParams:_}):Ve({values:f,minValue:l,maxValue:u,useSampleStdDev:!a,supportsNullCount:m,percentileParams:_});return jt(S,h)}async createUniqueValuesResponse(e,t){const{field:i,valueExpression:s,domain:r,returnAllCodedValues:a,scale:o}=t,l=await this._getDataValues(e,{field:i,valueExpression:s,scale:o}),u=Ot(l);return qt(u,r,a)}async createClassBreaksResponse(e,t){const{field:i,valueExpression:s,normalizationField:r,normalizationType:a,normalizationTotal:o,classificationMethod:l,standardDeviationInterval:u,minValue:c,maxValue:h,numClasses:f,scale:m}=t,d=await this._getDataValues(e,{field:i,valueExpression:s,normalizationField:r,normalizationType:a,normalizationTotal:o,scale:m}),_=Zt(d,{field:i,normalizationField:r,normalizationType:a,normalizationTotal:o,classificationMethod:l,standardDeviationInterval:u,minValue:c,maxValue:h,numClasses:f});return kt(_,l)}async createHistogramResponse(e,t){const{field:i,valueExpression:s,normalizationField:r,normalizationType:a,normalizationTotal:o,classificationMethod:l,standardDeviationInterval:u,minValue:c,maxValue:h,numBins:f,scale:m}=t,d=await this._getDataValues(e,{field:i,valueExpression:s,normalizationField:r,normalizationType:a,normalizationTotal:o,scale:m});return Bt(d,{field:i,normalizationField:r,normalizationType:a,normalizationTotal:o,classificationMethod:l,standardDeviationInterval:u,minValue:c,maxValue:h,numBins:f})}_sortFeatures(e,t,i){if(e.length>1&&t&&t.length)for(const s of t.reverse()){const r=s.split(" "),a=r[0],o=this.fieldsIndex.get(a),l=r[1]&&r[1].toLowerCase()==="desc",u=Ut(o==null?void 0:o.type,l);e.sort((c,h)=>{const f=i(c,a,o),m=i(h,a,o);return u(f,m)})}}_createFeatureQueryResponse(e){const t=this.items,{geometryType:i,hasM:s,hasZ:r,objectIdField:a,spatialReference:o}=this,{outFields:l,outSR:u,quantizationParameters:c,resultRecordCount:h,resultOffset:f,returnZ:m,returnM:d}=e,_=h!=null&&t.length>(f||0)+h,S=l&&(l.includes("*")?[...this.fieldsIndex.fields]:l.map(w=>this.fieldsIndex.get(w)));return{exceededTransferLimit:_,features:this._createFeatures(e,t),fields:S,geometryType:i,hasM:s&&d,hasZ:r&&m,objectIdFieldName:a,spatialReference:L(u||o),transform:c&&be(c)||null}}_createFeatures(e,t){const i=new te(e,this.featureAdapter,this.fieldsIndex),{hasM:s,hasZ:r}=this,{orderByFields:a,quantizationParameters:o,returnGeometry:l,returnCentroid:u,maxAllowableOffset:c,resultOffset:h,resultRecordCount:f,returnZ:m=!1,returnM:d=!1}=e,_=r&&m,S=s&&d;let w=[],p=0;const x=[...t];if(this._sortFeatures(x,a,(y,g,v)=>i.getFieldValue(y,g,v)),l||u){const y=be(o);if(l&&!u)for(const g of x)w[p++]={attributes:i.getAttributes(g),geometry:C(this.geometryType,this.hasZ,this.hasM,this.featureAdapter.getGeometry(g),c,y,_,S)};else if(!l&&u)for(const g of x)w[p++]={attributes:i.getAttributes(g),centroid:Ce(this,this.featureAdapter.getCentroid(g,this),y)};else for(const g of x)w[p++]={attributes:i.getAttributes(g),centroid:Ce(this,this.featureAdapter.getCentroid(g,this),y),geometry:C(this.geometryType,this.hasZ,this.hasM,this.featureAdapter.getGeometry(g),c,y,_,S)}}else for(const y of x){const g=i.getAttributes(y);g&&(w[p++]={attributes:g})}const I=h||0;if(f!=null){const y=I+f;w=w.slice(I,Math.min(w.length,y))}return w}_createExceedsLimitQueryResponse(e){let t=!1,i=Number.POSITIVE_INFINITY,s=Number.POSITIVE_INFINITY,r=Number.POSITIVE_INFINITY;for(const a of e.outStatistics)if(a.statisticType==="exceedslimit"){i=a.maxPointCount!=null?a.maxPointCount:Number.POSITIVE_INFINITY,s=a.maxRecordCount!=null?a.maxRecordCount:Number.POSITIVE_INFINITY,r=a.maxVertexCount!=null?a.maxVertexCount:Number.POSITIVE_INFINITY;break}if(this.geometryType==="esriGeometryPoint")t=this.items.length>i;else if(this.items.length>s)t=!0;else{const a=this.hasZ?this.hasM?4:3:this.hasM?3:2,o=this.featureAdapter;t=this.items.reduce((l,u)=>{const c=o.getGeometry(u);return l+(H(c)&&c.coords.length||0)},0)/a>r}return{fields:[{name:"exceedslimit",type:"esriFieldTypeInteger",alias:"exceedslimit",sqlType:"sqlTypeInteger",domain:null,defaultValue:null}],features:[{attributes:{exceedslimit:Number(t)}}]}}async _createStatisticsQueryResponse(e){const t={attributes:{}},i=[],s=new Map,r=new Map,a=new Map,o=new Map,l=new te(e,this.featureAdapter,this.fieldsIndex),u=e.outStatistics,{groupByFieldsForStatistics:c,having:h,orderByFields:f}=e,m=c&&c.length,d=!!m,_=d&&c[0],S=d&&!this.fieldsIndex.get(_);for(const p of u){const{outStatisticFieldName:x,statisticType:I}=p,y=p,g=I!=="exceedslimit"?p.onStatisticField:void 0,v=I==="percentile_disc"||I==="percentile_cont",E=I==="EnvelopeAggregate"||I==="CentroidAggregate"||I==="ConvexHullAggregate",N=d&&m===1&&(g===_||S)&&I==="count";if(d){if(!a.has(g)){const z=[];for(const j of c){const ee=this._getAttributeValues(l,j,s);z.push(ee)}a.set(g,this._calculateUniqueValues(z,l.returnDistinctValues))}const b=a.get(g);for(const z in b){const{count:j,data:ee,items:xe,itemPositions:et}=b[z],_e=ee.join(",");if(!h||l.validateItems(xe,h)){const O=o.get(_e)||{attributes:{}};if(E){O.aggregateGeometries||(O.aggregateGeometries={});const{aggregateGeometries:$,outStatisticFieldName:q}=await this._getAggregateGeometry(y,xe);O.aggregateGeometries[q]=$}else{let $=null;if(N)$=j;else{const q=this._getAttributeValues(l,g,s),we=et.map(tt=>q[tt]);$=v&&"statisticParameters"in y?this._getPercentileValue(y,we):this._getStatisticValue(y,we,null,l.returnDistinctValues)}O.attributes[x]=$}c.forEach(($,q)=>O.attributes[this.fieldsIndex.get($)?$:`EXPR_${q+1}`]=ee[q]),o.set(_e,O)}}}else if(E){t.aggregateGeometries||(t.aggregateGeometries={});const{aggregateGeometries:b,outStatisticFieldName:z}=await this._getAggregateGeometry(y,this.items);t.aggregateGeometries[z]=b}else{const b=this._getAttributeValues(l,g,s);t.attributes[x]=v&&"statisticParameters"in y?this._getPercentileValue(y,b):this._getStatisticValue(y,b,r,l.returnDistinctValues)}i.push({name:x,alias:x,type:"esriFieldTypeDouble"})}const w=d?Array.from(o.values()):[t];return this._sortFeatures(w,f,(p,x)=>p.attributes[x]),{fields:i,features:w}}async _getAggregateGeometry(e,t){const i=await import("./geometryEngineJSON.5b19a683.js"),{statisticType:s,outStatisticFieldName:r}=e,{featureAdapter:a,spatialReference:o,geometryType:l,hasZ:u,hasM:c}=this,h=t.map(d=>C(l,u,c,a.getGeometry(d))),f=i.convexHull(o,h,!0)[0],m={aggregateGeometries:null,outStatisticFieldName:null};if(s==="EnvelopeAggregate"){const d=f?_t(f):ue(i.union(o,h));m.aggregateGeometries=re(Y({},d),{spatialReference:o}),m.outStatisticFieldName=r||"extent"}else if(s==="CentroidAggregate"){const d=f?wt(f):St(ue(i.union(o,h)));m.aggregateGeometries={x:d[0],y:d[1],spatialReference:o},m.outStatisticFieldName=r||"centroid"}else s==="ConvexHullAggregate"&&(m.aggregateGeometries=f,m.outStatisticFieldName=r||"convexHull");return m}_getStatisticValue(e,t,i,s){const{onStatisticField:r,statisticType:a}=e;let o=null;return o=i!=null&&i.has(r)?i.get(r):ve(this.fieldsIndex.get(r))?Qe({values:t,returnDistinct:s}):Ve({values:t,minValue:null,maxValue:null,useSampleStdDev:!0}),i&&i.set(r,o),o[a==="var"?"variance":a]}_getPercentileValue(e,t){const{onStatisticField:i,statisticParameters:s,statisticType:r}=e,{value:a,orderBy:o}=s,l=this.fieldsIndex.get(i),u={value:a,orderBy:o,fieldType:l==null?void 0:l.type,isDiscrete:r==="percentile_disc"};return Lt(t,u)}_getAttributeValues(e,t,i){if(i.has(t))return i.get(t);const s=this.fieldsIndex.get(t),r=this.items.map(a=>e.getFieldValue(a,t,s));return i.set(t,r),r}_getAttributeNormalizedValues(e,t){return this.items.map(i=>e.getNormalizedValue(i,{field:t.field,fieldInfo:this.fieldsIndex.get(t.field),normalizationField:t.normalizationField,normalizationFieldInfo:this.fieldsIndex.get(t.normalizationField),normalizationType:t.normalizationType,normalizationTotal:t.normalizationTotal}))}async _getAttributeExpressionValues(e,t,i){const{arcadeUtils:s}=await qe(),r=s.createFunction(t),a=i&&s.getViewInfo(i);return this.items.map(o=>e.getExpressionValue(o,{compiledFunc:r,viewInfo:a},s))}_calculateUniqueValues(e,t){const i={},s=this.items,r=s.length;for(let a=0;a<r;a++){const o=s[a],l=[];for(const c of e)l.push(c[a]);const u=l.join(",");t?i[u]==null&&(i[u]={count:1,data:l,items:[o],itemPositions:[a]}):i[u]==null?i[u]={count:1,data:l,items:[o],itemPositions:[a]}:(i[u].count++,i[u].items.push(o),i[u].itemPositions.push(a))}return i}async _getDataValues(e,t){const i=new te(e,this.featureAdapter,this.fieldsIndex),{valueExpression:s,field:r,normalizationField:a,normalizationType:o,normalizationTotal:l,scale:u}=t,c=s?{viewingMode:"map",scale:u,spatialReference:e.outSR||this.spatialReference}:null;return s?this._getAttributeExpressionValues(i,s,c):this._getAttributeNormalizedValues(i,{field:r,normalizationField:a,normalizationType:o,normalizationTotal:l})}}function mi(n,e,t,i,s,r){const a=s-t,o=r-i,l=a*a+o*o,u=(n-t)*a+(e-i)*o,c=Math.min(1,Math.max(0,u/l));return{x:t+a*c,y:i+o*c}}function pi(n,e){return n?e?4:3:e?3:2}var K;(function(n){n[n.NONE=0]="NONE",n[n.EDGE=1]="EDGE",n[n.VERTEX=2]="VERTEX"})(K||(K={}));function yi(n){return n==="mesh"?It:Rt(n)}function Xe(n,e){return n?e?4:3:e?3:2}function gi(n,e,t,i){return Ke(n,e,t,i.coords[0],i.coords[1])}function xi(n,e,t,i,s,r){const a=Xe(s,r),{coords:o,lengths:l}=i;if(!l)return!1;for(let u=0,c=0;u<l.length;u++,c+=a)if(!Ke(n,e,t,o[c],o[c+1]))return!1;return!0}function Ke(n,e,t,i,s){if(!n)return!1;const r=Xe(e,t),{coords:a,lengths:o}=n;let l=!1,u=0;for(const c of o)l=_i(l,a,r,u,c,i,s),u+=c*r;return l}function _i(n,e,t,i,s,r,a){let o=n,l=i;for(let u=i,c=i+s*t;u<c;u+=t){l=u+t,l===c&&(l=i);const h=e[u],f=e[u+1],m=e[l],d=e[l+1];(f<a&&d>=a||d<a&&f>=a)&&h+(a-f)/(d-f)*(m-h)<r&&(o=!o)}return o}const le="feature-store:unsupported-query",wi={esriSpatialRelIntersects:"intersects",esriSpatialRelContains:"contains",esriSpatialRelCrosses:"crosses",esriSpatialRelDisjoint:"disjoint",esriSpatialRelEnvelopeIntersects:"intersects",esriSpatialRelIndexIntersects:null,esriSpatialRelOverlaps:"overlaps",esriSpatialRelTouches:"touches",esriSpatialRelWithin:"within",esriSpatialRelRelation:null},ge={spatialRelationship:{esriSpatialRelIntersects:!0,esriSpatialRelContains:!0,esriSpatialRelWithin:!0,esriSpatialRelCrosses:!0,esriSpatialRelDisjoint:!0,esriSpatialRelTouches:!0,esriSpatialRelOverlaps:!0,esriSpatialRelEnvelopeIntersects:!0,esriSpatialRelIndexIntersects:!1,esriSpatialRelRelation:!1},queryGeometry:{esriGeometryPoint:!0,esriGeometryMultipoint:!0,esriGeometryPolyline:!0,esriGeometryPolygon:!0,esriGeometryEnvelope:!0},layerGeometry:{esriGeometryPoint:!0,esriGeometryMultipoint:!0,esriGeometryPolyline:!0,esriGeometryPolygon:!0,esriGeometryEnvelope:!1}};function Si(n){return ge.spatialRelationship[n]===!0}function Ii(n){return ge.queryGeometry[bt(n)]===!0}function Ri(n){return ge.layerGeometry[n]===!0}function Fi(){return import("./geometryEngineJSON.5b19a683.js")}function Pe(n,e,t,i,s){if(se(e)&&t==="esriGeometryPoint"&&(n==="esriSpatialRelIntersects"||n==="esriSpatialRelContains")){const r=Te(new X,e,!1,!1);return Promise.resolve(a=>gi(r,!1,!1,a))}if(se(e)&&t==="esriGeometryMultipoint"){const r=Te(new X,e,!1,!1);if(n==="esriSpatialRelContains")return Promise.resolve(a=>xi(r,!1,!1,a,i,s))}if(W(e)&&t==="esriGeometryPoint"&&(n==="esriSpatialRelIntersects"||n==="esriSpatialRelContains"))return Promise.resolve(r=>Ft(e,C(t,i,s,r)));if(W(e)&&t==="esriGeometryMultipoint"&&n==="esriSpatialRelContains")return Promise.resolve(r=>vt(e,C(t,i,s,r)));if(W(e)&&n==="esriSpatialRelIntersects"){const r=yi(t);return Promise.resolve(a=>r(e,C(t,i,s,a)))}return Fi().then(r=>{const a=r[wi[n]].bind(null,e.spatialReference,e);return o=>a(C(t,i,s,o))})}async function Ne(n,e,t){const{spatialRel:i,geometry:s}=n;if(s){if(!Si(i))throw new R(le,"Unsupported query spatial relationship",{query:n});if(J(s.spatialReference)&&J(t)){if(!Ii(s))throw new R(le,"Unsupported query geometry type",{query:n});if(!Ri(e))throw new R(le,"Unsupported layer geometry type",{query:n});if(n.outSR)return U(n.geometry&&n.geometry.spatialReference,n.outSR)}}}function De(n){if(W(n))return!0;if(se(n)){for(const e of n.rings)if(e.length!==5||e[0][0]!==e[1][0]||e[0][0]!==e[4][0]||e[2][0]!==e[3][0]||e[0][1]!==e[3][1]||e[0][1]!==e[4][1]||e[1][1]!==e[2][1])return!1;return!0}return!1}function vi(n){return n.every(e=>e.statisticType!=="exceedslimit")}const Q="feature-store:unsupported-query",ie=new Set,bi=new Tt(2e6);let Ti=0;class Mi{constructor(e){this.capabilities={query:Pt},this.geometryType=e.geometryType,this.hasM=e.hasM,this.hasZ=e.hasZ,this.objectIdField=e.objectIdField,this.spatialReference=e.spatialReference,this.definitionExpression=e.definitionExpression,this.featureStore=e.featureStore,this.aggregateAdapter=e.aggregateAdapter,this._changeHandle=this.featureStore.events.on("changed",()=>this.clearCache()),this.timeInfo=e.timeInfo,e.cacheSpatialQueries&&(this._geometryQueryCache=new At(Ti+++"$$",bi)),this.fieldsIndex=new Et(e.fields),e.scheduler&&e.priority&&(this._frameTask=e.scheduler.registerTask(e.priority))}destroy(){this._frameTask=Ae(this._frameTask),this.clearCache(),Ee(this._geometryQueryCache),this._changeHandle=Ae(this._changeHandle),Ee(this.fieldsIndex)}get featureAdapter(){return this.featureStore.featureAdapter}get fullExtent(){const e=this.featureStore.fullBounds;return e?{xmin:e[0],ymin:e[1],xmax:e[2],ymax:e[3],spatialReference:L(this.spatialReference)}:null}get timeExtent(){return this.timeInfo?(this._timeExtent||(this._timeExtent=si(this.timeInfo,this.featureStore)),this._timeExtent):null}clearCache(){this._geometryQueryCache&&this._geometryQueryCache.clear(),this._allItems=null,this._timeExtent=null}async executeQuery(e={},t){let i,s=Z(e);try{s=await this._schedule(()=>k(s,this.definitionExpression,this.spatialReference),t),s=await this._reschedule(()=>this._checkQuerySupport(s),t),i=await this._reschedule(()=>this._executeGeometryQuery(s,t),t),i=await this._reschedule(()=>i.executeAggregateIdsQuery(s),t),i=await this._reschedule(()=>i.executeObjectIdsQuery(s),t),i=await this._reschedule(()=>i.executeTimeQuery(s),t),i=await this._reschedule(()=>i.executeAttributesQuery(s),t)}catch(r){if(r!==V)throw r;i=new F([],null,this)}return i.createQueryResponse(s)}async executeQueryForCount(e={},t){let i=Z(e);i.returnGeometry=!1,i.returnCentroid=!1,i.outSR=null;try{i=await this._schedule(()=>k(i,this.definitionExpression,this.spatialReference),t),i=await this._reschedule(()=>this._checkQuerySupport(i),t);let s=await this._reschedule(()=>this._executeGeometryQuery(i,t),t);return s=await this._reschedule(()=>s.executeAggregateIdsQuery(i),t),s=await this._reschedule(()=>s.executeObjectIdsQuery(i),t),s=await this._reschedule(()=>s.executeTimeQuery(i),t),s=await this._reschedule(()=>s.executeAttributesQuery(i),t),s.createQueryResponseForCount(i)}catch(s){if(s!==V)throw s;return 0}}async executeQueryForExtent(e={},t){let i,s=Z(e);const r=s.outSR;try{s=await this._schedule(()=>k(s,this.definitionExpression,this.spatialReference),t),s=await this._reschedule(()=>this._checkQuerySupport(s),t),s.returnGeometry=!0,s.returnCentroid=!1,s.outSR=null,i=await this._reschedule(()=>this._executeGeometryQuery(s,t),t),i=await this._reschedule(()=>i.executeAggregateIdsQuery(s),t),i=await this._reschedule(()=>i.executeObjectIdsQuery(s),t),i=await this._reschedule(()=>i.executeTimeQuery(s),t),i=await this._reschedule(()=>i.executeAttributesQuery(s),t);const a=i.size;if(!a)return{count:a,extent:null};zt(T,$t),this.featureStore.forEachBounds(i.items,u=>Qt(T,u),Ai);const o={xmin:T[0],ymin:T[1],xmax:T[3],ymax:T[4],spatialReference:L(this.spatialReference)};this.hasZ&&isFinite(T[2])&&isFinite(T[5])&&(o.zmin=T[2],o.zmax=T[5]);const l=M(o,i.spatialReference,r);if(l.spatialReference=L(r||this.spatialReference),l.xmax-l.xmin==0){const u=ae(l.spatialReference);l.xmin-=u,l.xmax+=u}if(l.ymax-l.ymin==0){const u=ae(l.spatialReference);l.ymin-=u,l.ymax+=u}if(this.hasZ&&l.zmin!=null&&l.zmax!=null&&l.zmax-l.zmin==0){const u=ae(l.spatialReference);l.zmin-=u,l.zmax+=u}return{count:a,extent:l}}catch(a){if(a===V)return{count:0,extent:null};throw a}}async executeQueryForIds(e={},t){return this.executeQueryForIdSet(e,t).then(i=>Array.from(i))}async executeQueryForIdSet(e={},t){let i,s=Z(e);s.returnGeometry=!1,s.returnCentroid=!1,s.outSR=null;try{s=await this._schedule(()=>k(s,this.definitionExpression,this.spatialReference),t),s=await this._reschedule(()=>this._checkQuerySupport(s),t),i=await this._reschedule(()=>this._executeGeometryQuery(s,t),t),i=await this._reschedule(()=>i.executeAggregateIdsQuery(s),t),i=await this._reschedule(()=>i.executeObjectIdsQuery(s),t),i=await this._reschedule(()=>i.executeTimeQuery(s),t),i=await this._reschedule(()=>i.executeAttributesQuery(s),t);const r=i.items,a=new Set;return await this._reschedule(()=>{for(const o of r)a.add(i.featureAdapter.getObjectId(o))},t),a}catch(r){if(r===V)return new Set;throw r}}async executeQueryForSnapping(e,t){const{point:i,distance:s,types:r}=e;if(r===K.NONE)return{candidates:[]};const a=await this._reschedule(()=>this._checkQuerySupport(e.query),t),o=!D(i.spatialReference,this.spatialReference);o&&await U(i.spatialReference,this.spatialReference);const l=typeof s=="number"?s:s.x,u=typeof s=="number"?s:s.y,c={xmin:i.x-l,xmax:i.x+l,ymin:i.y-u,ymax:i.y+u,spatialReference:i.spatialReference},h=o?M(c,this.spatialReference):c;if(!h)return{candidates:[]};const f=(await ce(he(i),null,{signal:t}))[0],m=(await ce(he(h),null,{signal:t}))[0];if(A(f)||A(m))return{candidates:[]};let d=new F(this._searchFeatures(this._getQueryBBoxes(m.toJSON())),null,this);d=await this._reschedule(()=>d.executeObjectIdsQuery(a),t),d=await this._reschedule(()=>d.executeTimeQuery(a),t),d=await this._reschedule(()=>d.executeAttributesQuery(a),t);const _=f.toJSON(),S=o?M(_,this.spatialReference):_,w=o?Math.max(h.xmax-h.xmin,h.ymax-h.ymin)/2:s;return d.createSnappingResponse(re(Y({},e),{point:S,distance:w}),i.spatialReference)}async executeQueryForLatestObservations(e={},t){if(!this.timeInfo||!this.timeInfo.trackIdField)throw new R(Q,"Missing timeInfo or timeInfo.trackIdField",{query:e,timeInfo:this.timeInfo});let i,s=Z(e);try{s=await this._schedule(()=>k(s,this.definitionExpression,this.spatialReference),t),s=await this._reschedule(()=>this._checkQuerySupport(s),t),i=await this._reschedule(()=>this._executeGeometryQuery(s,t),t),i=await this._reschedule(()=>i.executeAggregateIdsQuery(s),t),i=await this._reschedule(()=>i.executeObjectIdsQuery(s),t),i=await this._reschedule(()=>i.executeTimeQuery(s),t),i=await this._reschedule(()=>i.executeAttributesQuery(s),t),i=await this._reschedule(()=>i.filterLatest(),t)}catch(r){if(r!==V)throw r;i=new F([],null,this)}return i.createQueryResponse(s)}async executeQueryForSummaryStatistics(e={},t,i){const{field:s,normalizationField:r,valueExpression:a}=t;return(await this._getQueryEngineResultForStats(e,{field:s,normalizationField:r,valueExpression:a},i)).createSummaryStatisticsResponse(e,t)}async executeQueryForUniqueValues(e={},t,i){const{field:s,valueExpression:r}=t;return(await this._getQueryEngineResultForStats(e,{field:s,valueExpression:r},i)).createUniqueValuesResponse(e,t)}async executeQueryForClassBreaks(e={},t,i){const{field:s,normalizationField:r,valueExpression:a}=t;return(await this._getQueryEngineResultForStats(e,{field:s,normalizationField:r,valueExpression:a},i)).createClassBreaksResponse(e,t)}async executeQueryForHistogram(e={},t,i){const{field:s,normalizationField:r,valueExpression:a}=t;return(await this._getQueryEngineResultForStats(e,{field:s,normalizationField:r,valueExpression:a},i)).createHistogramResponse(e,t)}async _schedule(e,t){return H(this._frameTask)?this._frameTask.schedule(e,t):e(ze)}async _reschedule(e,t){return H(this._frameTask)?this._frameTask.reschedule(e,t):e(ze)}_getAll(){if(!this._allItems){const e=[];this.featureStore.forEach(t=>e.push(t)),this._allItems=new F(e,null,this)}return this._allItems}async _executeGeometryQuery(e,t){const{geometry:i,outSR:s,spatialRel:r,returnGeometry:a,returnCentroid:o}=e,l=this.featureStore.featureSpatialReference,u=i&&l&&l!==i.spatialReference?M(i,l):i,c=a||o,h=J(s)&&!D(this.spatialReference,s),f=this._geometryQueryCache?h&&c?JSON.stringify({originalFilterGeometry:i,spatialRelationship:r,outSpatialReference:s}):JSON.stringify({originalFilterGeometry:i,spatialRelationship:r}):null;if(f){const p=this._geometryQueryCache.get(f);if(!Vt(p))return p}const m=async p=>{if(h&&c){const x=await p.project(s);return f&&this._geometryQueryCache.put(f,x,x.size||1),x}return f&&this._geometryQueryCache.put(f,p,p.size||1),p};if(!u)return m(this._getAll());const d=this.featureAdapter;if(r==="esriSpatialRelDisjoint"){const p=this._searchFeatures(this._getQueryBBoxes(i));if(!p.length)return m(this._getAll());let x,I;const y=new Set;for(const v of p)y.add(d.getObjectId(v));await this._reschedule(()=>{let v=0;x=new Array(y.size),this.featureStore.forEach(E=>x[v++]=E),I=y},t);const g=await this._reschedule(async()=>{const v=await Pe(r,u,this.geometryType,this.hasZ,this.hasM),E=N=>!I.has(d.getObjectId(N))||v(d.getGeometry(N));return new F(await this._runSpatialFilter(x,E,t),i,this)},t);return m(g)}const _=this._searchFeatures(this._getQueryBBoxes(i));if(!_.length){const p=new F([],i,this);return f&&this._geometryQueryCache.put(f,p,p.size||1),p}if(this._canExecuteSoloPass(u,e))return m(new F(_,i,this));const S=await Pe(r,u,this.geometryType,this.hasZ,this.hasM),w=await this._runSpatialFilter(_,p=>S(d.getGeometry(p)),t);return m(new F(w,i,this))}async _runSpatialFilter(e,t,i){if(!t)return e;if(A(this._frameTask))return e.filter(o=>t(o));let s=0;const r=new Array,a=async o=>{for(;s<e.length;){const l=e[s++];t(l)&&(r.push(l),o.madeProgress()),o.done&&await this._reschedule(u=>a(u),i)}};return this._reschedule(o=>a(o),i).then(()=>r)}_canExecuteSoloPass(e,t){const{geometryType:i}=this,{spatialRel:s}=t;return De(e)&&(s==="esriSpatialRelEnvelopeIntersects"||i==="esriGeometryPoint"&&(s==="esriSpatialRelIntersects"||s==="esriSpatialRelContains"||s==="esriSpatialRelWithin"))}_getQueryBBoxes(e){if(De(e)){if(W(e))return[$e(e.xmin,e.ymin,e.xmax,e.ymax)];if(se(e))return e.rings.map(t=>$e(Math.min(t[0][0],t[2][0]),Math.min(t[0][1],t[2][1]),Math.max(t[0][0],t[2][0]),Math.max(t[0][1],t[2][1])))}return[Gt(Mt(),e)]}_searchFeatures(e){for(const s of e)this.featureStore.forEachInBounds(s,r=>{ie.add(r)});const t=new Array(ie.size);let i=0;return ie.forEach(s=>t[i++]=s),ie.clear(),t}async _checkStatisticsSupport(e,t){if(e.distance<0||e.geometryPrecision!=null||e.multipatchOption||e.pixelSize||e.relationParam||e.text||e.outStatistics||e.groupByFieldsForStatistics||e.having||e.orderByFields)throw new R(Q,"Unsupported query options",{query:e});return Promise.all([this._checkAttributesQuerySupport(e),this._checkStatisticsParamsSupport(t),Ne(e,this.geometryType,this.spatialReference),U(this.spatialReference,e.outSR)]).then(()=>e)}async _checkStatisticsParamsSupport(e){let t=[];if(e.valueExpression){const{arcadeUtils:i}=await qe();t=i.extractFieldNames(e.valueExpression)}if(e.field&&t.push(e.field),e.normalizationField&&t.push(e.normalizationField),!t.length)throw new R(Q,"params should have at least a field or valueExpression",{params:e});G(this.fieldsIndex,t,"params contains missing fields")}async _checkQuerySupport(e){if(e.distance<0||e.geometryPrecision!=null||e.multipatchOption||e.pixelSize||e.relationParam||e.text)throw new R(Q,"Unsupported query options",{query:e});return Promise.all([this._checkAttributesQuerySupport(e),this._checkStatisticsQuerySupport(e),Ne(e,this.geometryType,this.spatialReference),U(this.spatialReference,e.outSR)]).then(()=>e)}_checkAttributesQuerySupport(e){const{outFields:t,orderByFields:i,returnDistinctValues:s,outStatistics:r}=e,a=r?r.map(o=>o.outStatisticFieldName&&o.outStatisticFieldName.toLowerCase()).filter(Boolean):[];if(i&&i.length>0){const o=" asc",l=" desc",u=i.map(c=>{const h=c.toLowerCase();return h.includes(o)?h.split(o)[0]:h.includes(l)?h.split(l)[0]:c}).filter(c=>!a.includes(c));G(this.fieldsIndex,u,"orderByFields contains missing fields")}if(t&&t.length>0)G(this.fieldsIndex,t,"outFields contains missing fields");else if(s)throw new R(Q,"outFields should be specified for returnDistinctValues",{query:e});Kt(this.fieldsIndex,e.where)}async _checkStatisticsQuerySupport(e){const{outStatistics:t,groupByFieldsForStatistics:i,having:s}=e,r=i&&i.length,a=t&&t.length;if(s){if(!r||!a)throw new R(Q,"outStatistics and groupByFieldsForStatistics should be specified with having",{query:e});ei(this.fieldsIndex,s,t)}if(a){if(!vi(t))return;const o=t.map(l=>l.onStatisticField).filter(Boolean);G(this.fieldsIndex,o,"onStatisticFields contains missing fields"),r&&G(this.fieldsIndex,i,"groupByFieldsForStatistics contains missing fields");for(const l of t){const{onStatisticField:u,statisticType:c}=l;if((c==="percentile_disc"||c==="percentile_cont")&&"statisticParameters"in l){const{statisticParameters:h}=l;if(!h)throw new R(Q,"statisticParamters should be set for percentile type",{definition:l,query:e})}else if(c!=="count"&&u&&ii(u,this.fieldsIndex))throw new R(Q,"outStatistics contains non-numeric fields",{definition:l,query:e})}}}async _getQueryEngineResultForStats(e={},t,i){let s;e=Z(e);try{e=await this._schedule(()=>k(e,this.definitionExpression,this.spatialReference),i),e=await this._reschedule(()=>this._checkStatisticsSupport(e,t),i),s=await this._reschedule(()=>this._executeGeometryQuery(e,i),i),s=await this._reschedule(()=>s.executeAggregateIdsQuery(e),i),s=await this._reschedule(()=>s.executeObjectIdsQuery(e),i),s=await this._reschedule(()=>s.executeTimeQuery(e),i),s=await this._reschedule(()=>s.executeAttributesQuery(e),i)}catch(r){if(r!==V)throw r;s=new F([],null,this)}return s}}const Ai=Ze(),T=Ze();export{Mi as V,ci as Z,U as f,M as g,ri as n,Pe as v};
